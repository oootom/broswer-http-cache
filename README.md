## 前言

说起浏览器的 HTTP 缓存，总会提到强缓存、协商缓存、新鲜度、`Cache-Control`、`Expires`、`If-Modified-Since`、`If-None-Match`、`Last-Modified`、`ETags` 等关键词，它们对我来说既熟悉又陌生，总是记了又忘，忘了再记。归根到底是自己没有形成一个体系化的认知。

前不久看到了一篇文章《彻底弄懂浏览器缓存策略-基于缓存策略三要素分解法》，虽然时间久远，但是文中提出的缓存三大策略，即存储策略、过期策略、对比策略，让我有了一个系统学习缓存知识的路径，我也将基于这个思路，记录我的学习内容。

在学习缓存相关的知识前，要先明确一件事，浏览器为什么要缓存 HTTP 响应？

- 减少网络流量，节省带宽；
- 减少回源请求次数，减轻服务器负载；
- 提高页面加载速度，优化用户体验；

## 浏览器的 HTTP 缓存体系

浏览器的 HTTP 缓存体系分为以下三个部分：

- 缓存存储策略：响应是否可以被缓存、在哪些地方被缓存、缓存多久；
- 缓存过期策略：已存在的缓存是否可用、是否过期；
- 缓存对比策略：服务端如何对比客户端缓存与源站资源；

### 缓存存储策略

如上文所说，缓存存储策略是为了解决响应是否可以被缓存的问题。这一般取决于服务端的设置，或遵循浏览器的默认行为。

缓存存储策略受响应的 `Cache-Control` 头部或 `Expires` 头部的控制。`Cache-Control` 的取值 `max-age`、`no-cache`、`no-store` 都是用来指明响应内容是否可以被浏览器缓存的，其中前 2 种取值都会缓存文件数据（`no-cache` 应理解为“不建议使用本地缓存”，其仍然会缓存数据到本地），`no-store` 则不会在浏览器缓存任何响应数据。



> Cache-Control 的取值有很多，且要区别 request Cache-Control 与 response Cache-Control，对于 response Cache-Control 来说，有如下几种取值：
>
> 1. 基本缓存控制指令
>   - **no-store**：绝对禁止缓存数据。
>   - **no-cache**：资源可以被缓存，但在使用之前必须重新验证其有效性。
>   - **public**：指示响应可以被任何缓存区缓存。
>   - **private**：响应只能被单个用户的浏览器缓存，不适用于共享缓存（如代理服务器）。
>
>   2. 过期控制指令
>   - **max-age=[seconds]**：指定一个时间长度，在这段时间内，缓存被认为是新鲜的。
>   - **s-maxage=[seconds]**：类似于 `max-age`，但仅适用于共享缓存。
>   - **must-revalidate**：一旦缓存过期（即超过 `max-age`），必须去服务器验证是否有更新。
>   - **proxy-revalidate**：与 `must-revalidate` 类似，但仅适用于共享缓存。
>
>   3. 其他指令
>   - **immutable**：表明响应正文不会随时间改变，直到过期。
>   - **stale-while-revalidate=[seconds]**：在后台异步检查缓存的同时，客户端使用过期的缓存的时间。
>   - **stale-if-error=[seconds]**：如果在重新验证缓存时服务器出错，客户端使用过期的缓存的时间。
>
>   在此之上，这些指令可以组合使用。由于本文主要关注浏览器的缓存，因此先详细了解部分取值（`no-cache`、`no-store`、`max-age` 以及 `public`、`private`）。



我在本地搭建了一个简单的场景进行验证:

// image

分别使用 `<img>` 标签和 `fetch` API 去获取远程资源。对于图片资源，我需要浏览器缓存一段时间，对于 json 数据，我需要浏览器不缓存，因此我在 Server 端对响应设置了不同的 `Cache-Control`:

// image

再次请求页面时，发现浏览器确实缓存了图片资源，未缓存 json 数据:

// image

> 直接在浏览器的地址栏中输入 URL 去请求资源时，浏览器通常不会遵循常规缓存策略。因为这种请求行为往往更倾向于获取到最新的资源，避免因为使用了过时的缓存而导致问题或误解。
>
> 这与通过页面内元素（如 `<img>` 标签）或脚本（如 `fetch` API）发起的请求略有不同，后者更依赖并遵循 HTTP 缓存头的指示进行资源的缓存和重用。
>
> // image



如果一个响应设置了符合规范的 HTTP 头部，它的缓存存储策略是比较清晰的。但是如果没有设置 HTTP 头部，或者设置的 HTTP 头部不完整，缓存存储策略就要结合浏览器的默认行为来看。

**请求资源时，响应携带 Cache-Control: no-cache, 或 Cache-Control: max-age=0**

- 响应头中包含 `Cache-Control: no-cache` 时，意味着浏览器可以缓存这个资源。但是使用缓存资源时，浏览器必须向服务器验证这个缓存的资源是否仍然是最新的；
- 响应头中包含 `Cache-Control: max-age=0` 时，意味着浏览器可以缓存这个资源，但是缓存的最大有效时间为 0 秒，立即过期。使用缓存资源时，浏览器必须向服务器验证这个缓存的资源是否仍然是最新的；

**请求资源时，响应携带 Cache-Control: no-store**

- 这种情况下，响应被视为 "public"；
- 如果没有明确指定 private，且设置了 max-age，则默认为 public。这是因为设置了可以缓存的时间，但没有限制谁可以缓存；
- 但是对于某些特殊响应（如包含 Authorization 头的请求）可能默认被视为 private；

**请求资源时，服务端的响应携带了 Cache-Control: private，或  Cache-Control: public**

- 浏览器通常会缓存这个响应，因为 private 指令允许浏览器进行私有缓存；
- 由于没有明确的 max-age，浏览器会使用启发式缓存（heuristic caching）。启发式缓存：浏览器会根据其他响应头来估算一个合理的缓存时间。通常基于 Last-Modified 头（如果存在）。常见算法：如果有 Last-Modified，缓存时间可能是 (当前时间 - Last-Modified) 10%。例如，如果资源在5天前修改，可能会缓存约12小时；
- 不同浏览器可能有不同的启发式算法。一些浏览器可能默认缓存较短时间，如几小时或一天。
- 这种情况下的缓存行为不太可预测，且不同浏览器有不同表现。因此，建议总是明确指定 max-age 以控制缓存时间。如果响应中包含 Expires 头，浏览器可能会使用它来确定缓存时间。但 Cache-Control 通常优先于 Expires。
- 这种情况下，虽然缓存了响应，浏览器可能会频繁验证资源是否更新；

**请求资源时，服务端的响应没有携带 Cache-Control，携带了 Expires**

- 浏览器会使用 Expires 头部来决定是否缓存响应以及缓存多长时间；Expires 指定了一个明确的过期日期和时间，浏览器会将响应缓存到指定的时间。格式示例：Expires: Wed, 21 Oct 2023 07:28:00 GMT
- 浏览器会比较当前时间和 Expires 指定的时间。如果当前时间小于 Expires 时间，缓存被认为是有效的；
- 时钟同步问题：Expires 依赖于客户端的时钟，可能因时钟不同步导致问题；

**请求资源时，服务端的响应同时携带了 Cache-Control 和 Expires**

- Cache-Control 的优先级高于 Expires。现代浏览器主要遵循 Cache-Control 的指令，只有在 Cache-Control 缺失或不支持时才考虑 Expires；
- 如果 Cache-Control 和 Expires 指定的缓存时间不同，以 Cache-Control 为准；
- 建议主要依赖 Cache-Control 进行缓存控制。添加 Expires 作为后备和兼容性措施；

**请求资源时，服务端的响应没有携带 Cache-Control 和 Expires**

- 浏览器可能会采用启发式缓存（heuristic caching）。具体行为可能因浏览器而异；
- Content-Type 可能影响缓存决策。静态资源（如图片、CSS）更可能被缓存。动态内容可能不会被缓存或只短暂缓存；
- 对于 HTTPS 内容，没有明确缓存指令时，浏览器可能更倾向于不缓存；
- 即使缓存，浏览器可能会频繁验证资源是否更新；